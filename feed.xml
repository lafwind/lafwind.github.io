<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lafwind's blog</title>
  <subtitle>A developer...</subtitle>
  <id>http://lafwind.github.io</id>
  <link href="http://lafwind.github.io"/>
  <link href="http://lafwind.github.io/feed.xml" rel="self"/>
  <updated>2015-06-11T23:01:00+08:00</updated>
  <author>
    <name>Lafwind</name>
  </author>
  <entry>
    <title>My tools</title>
    <link rel="alternate" href="http://lafwind.github.io/my-tools.html"/>
    <id>http://lafwind.github.io/my-tools.html</id>
    <published>2015-06-11T23:01:00+08:00</published>
    <updated>2015-06-15T17:15:09+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;工欲善其事，必先利其器。下面是一些自己在日常开发中用到的工具：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux
大概在2012年9月份的时候开始使用Linux当自己的主力操作系统，用的是ubuntu发行版。之后的折腾也都是基于ubuntu上的。先从ubuntu跑到kubuntu，再到现在的&lt;a href="http://www.elementary.io/"&gt;Elementary OS&lt;/a&gt;。总体来说感觉很好，尤其是开发，在命令行下能解决大部分问题。虽然没有啥游戏，但好在自己不是很好这一口~&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Gvim/Vim
用Gvim/Vim的历史可以追溯到自己的高中时期 = =，虽然那时自己不搞开发，但是对所有新鲜的软件都很感兴趣，vim就是其中之一，虽然它的历史比我还长，但是在遇到它时，它对我而言是全新的。之后偶尔用它来处理文本（hjkl的训练在那时完成），Firefox上也装了Vimperator，瞬间幻觉自己X格提高了不少……之后把系统从windows切换到linux后，vim就顺理成章的成为自己的主力编辑器。没事就折腾代码配色，操作配置，有关插件等，直到它变得越来越顺手。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Emacs
没错，你没看错，我没打错，我们都没错（&lt;del&gt;，错的是这个世界~&lt;/del&gt;），除了vim，我还使用emacs……之所以使用它是因为在上面学习了些lisp，虽然lisp还没学好（会继续的！），但却把emacs配置得差不多……其实在使用过程中最大的收获还是知道了和vim完全不同的emacs的快捷键，而这一套快捷键不止可以在emacs中使用，在其他地方也有用武之地，比如命令行里同样支持C-a、C-e、C-f、C-b等的操作，而在Intellij idea IDE中，同样可以选择使用emacs的快捷键。而这也着实能在日常操作中提高效率（命令行），虽然相对于vim编辑时的高效，emacs的快捷键可能还有些差距（个人认为），但对于键盘党来说，仍然值得拥有！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;zsh &amp;amp; tmux
其实bash用得也蛮顺的，但是zsh着实帮我提高了不少效率。zsh的配置用的是&lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh&lt;/a&gt;，当然自己也根据情况进行了些修改。不过就像部分用户所说，oh-my-zsh好像有点重，一开始启动有时会比较慢。tmux被我拿来给终端分屏，不用每次开那么多的Terminal。开发Rails时，server运行一屏，vim一屏，console和普通命令行界面共享一屏（分居左右），用快捷键切换，很好。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Firefox &amp;amp; Chrome
Firefox大概从它的1.x版本开始用。配合着Vimperator、adblock plus等插件，用起来爽爽的。直到去年，在调某个网页的效果时，发现其和chrome的渲染好像还是有点差别的（更喜欢chrome的渲染），遂把主力浏览器换成chrome。对chrome的认识从它发布的那天开始，这主要是由于我曾经有很长一段时间陷入到寻找浏览器的坑里，手里主要用着Firefox，但是什么Opera，基于IE内核的其他浏览器、Safari等都没事就被我翻起来用用，再用用，这其中的原因当然是偶尔对手头的Firefox有不满 = =。所以chrome一出来，我就试用了，但由于不顺手（主要就是没有Firefox中Vimperator这种对我来说杀手级的add-on），最后还是回到Firefox怀抱。&lt;/p&gt;

&lt;p&gt;顺便说说，我之所以如此喜欢Vimperator，除了它能给我在浏览器中带来接近vim的高效操作外，还有就是它能让Firefox变得十分简洁，只有tab栏和命令栏，网页的可视界面很大，而且用起来很酷~~&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述就是自己在开发时用得主要工具，对我来说，它们能满足我的现有需求，而对于有些人来说可能还不够，这是正常的，每个人都有属于自己的独特需求嘛，自己用得舒服就好~下面是上述工具的相关配置，有需自取，欢迎交流：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.vimrc"&gt;.vimrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/tree/master/.emacs.d"&gt;.emacs.d&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.zshrc"&gt;.zshrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.tmux.conf"&gt;.tmux.conf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.vimperatorrc"&gt;.vimperatorrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>生活需要总结</title>
    <link rel="alternate" href="http://lafwind.github.io/thinking-in-life-20150609.html"/>
    <id>http://lafwind.github.io/thinking-in-life-20150609.html</id>
    <published>2015-06-09T23:16:00+08:00</published>
    <updated>2015-06-16T16:44:44+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;吾日三省吾身，谈谈近期的一些生活感想吧。&lt;/p&gt;

&lt;p&gt;前两天在网上闲逛，不小心闯进了一个技术博客。内容写得很好，再看了下About页面，瞬间被震惊了……高中生……只能扶额捂脸。虽然高中时自己也对IT方面的内容感兴趣，但都流于表面，没事装装新的软件，配置成自己喜欢的样子……或者看看各大IT公司有没有出啥好玩的新东西，然后见识虽然广了，但都是些虚的 = =，再看看现在的有些高中生，有点悔不当初。不过想多了也没用，不是有句话这样说嘛，从现在开始的每一天都是你有生之年最年轻的时刻，所以只能干了！&lt;/p&gt;

&lt;p&gt;最近都在听podcast，有英文的，也有中文的。英文的一般第一遍都听得不是很懂，只能多听几遍，不过由于没懂，往往每次都有新的收获，顺便也练练英文～中文的听起来就没这么费劲，学到的东西也很多～听大牛们有深度的“闲话瞎扯”，有技术内容的，有设计相关的，有自然科学的，有人文历史的，不得不感叹他们的知识广度和深度，而从谈话内容和主持人、嘉宾身上也能找到之后努力的方向和改变对一些事物的看法。真的很有裨益。&lt;/p&gt;

&lt;p&gt;关于学习，这段时间仍然着重于Ruby和Rails。没事复习复习&lt;a href="https://github.com/lafwind/notes_of_metaprogramming_ruby"&gt;元编程&lt;/a&gt;，看看Ruby-China上的一些精华技术贴，或者是打开&lt;a href="http://devdocs.io/"&gt;Devdocs&lt;/a&gt;看看Ruby的一些相关文档。对于其他新技术，也有关注，尤其前端，尤其JS，当然还有之前说的Rust。最近在新项目中，尝试使用haml和sass代替html和css，的确很爽，有时间再试试slim。JS要好好学，当然还有CoffeeScript。计算机底层的东西也要好好修炼，《SICP》整天压在书包里，是时候再续前缘了！前段时间买的《Redis设计与实现》也不要浪费，看看C，看看数据结构，看看Redis。发现自己对Redis这种短小精悍的东西很有好感，vim就是一个典型的例子。&lt;/p&gt;

&lt;p&gt;然后也开始想看一些设计相关的书籍，比如&lt;a href="http://book.douban.com/subject/3323633/"&gt;《写给大家看的设计书》&lt;/a&gt;，毕竟自己还是很希望能够做出有设计感、优雅漂亮的网页。说到设计，想起之前听的某期podcast中主持人关于设计的讨论，一个设计师设计出一个扁平化（时下潮流，当然，仍有些设计是坚持拟物的）的网页是基于其对美的追求还是只是追随时尚？设计是应该领导潮流的还是基于潮流的基础？关于这个问题，我个人的看法是设计有大有小，大的引领潮流，小的在潮流里追求极致，设计师也是普通人，也有追求时尚的权利，只要他们做的设计是他们觉得美丽的事物即可。当然，一个只是一味符合市场需求而无法坚持本心（对于美的追求）的设计师不是一个好的设计师。&lt;/p&gt;

&lt;p&gt;上述是近期生活的一个概况，平平淡淡，但经过瞎想，也能咀嚼出点味儿来～思考生活，然后继续生活吧。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rust</title>
    <link rel="alternate" href="http://lafwind.github.io/rust.html"/>
    <id>http://lafwind.github.io/rust.html</id>
    <published>2015-06-07T23:30:00+08:00</published>
    <updated>2015-06-15T17:02:37+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="http://www.rust-lang.org/"&gt;Rust&lt;/a&gt;这门语言在它还是0.4版本的时候就听过，应该是看到一些关于新兴语言的讨论才注意到的。由于当时语言特性还没定下来，也没怎么去看，就当知道有这么一门和Golang同辈的语言。&lt;/p&gt;

&lt;p&gt;再之后就是到去年8月份，暑假的时候，在网上瞎溜达，又看到了一篇关于Rust的教程，大致瞄了几眼，此时它还处于0.1x版本，就想着等它1.0正式版的时候，再回来学学。&lt;/p&gt;

&lt;p&gt;之所以想学这门语言，有如下原因吧：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;很多很酷的人说它很酷。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;想学一门系统编程语言。觉得系统型语言更能接触到计算机的底层，帮助了解计算机的内部，扎实基础（修炼内功），虽然自己比较喜欢web开发方面的内容，但夯实的基础应该能够帮助自己成为更好的开发者。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它很新~&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于上述原因，在5月16日Rust 1.0版本发布后，就一直想找机会学学。在写下这篇文章的时候，自己刚刚看了Rust官方提供的book的前两章并跟着写了几个例子，感受如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;安装容易。因为自己是在Linux下安装的，照着&lt;a href="http://www.rust-lang.org/install.html"&gt;官方的命令行安装教程&lt;/a&gt;，一条命令就足够了：&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt; &lt;span class="nv"&gt;$ &lt;/span&gt;curl -sSf https://static.rust-lang.org/rustup.sh | sh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://crates.io/"&gt;Cargo&lt;/a&gt;很好用。利用Cargo可以很快的新建一个Rust项目，并进行项目的相关配置。这一点和Rails很像，这可能是由于Cargo的作者也具有Ruby的背景吧～&lt;/p&gt;
&lt;pre class="highlight shell"&gt;&lt;code&gt; &lt;span class="nv"&gt;$ &lt;/span&gt;Cargo new hello --bin
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;语法和C有点相似，但仅仅就是看起来像，细节内容方面还是不同的。个人还是比较喜欢这种风格的（还有&lt;code&gt;do...end&lt;/code&gt;这样的）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;符号很多，比较复杂，可能是自己还未深入了解语法细节和，就只跟着写了几行代码的缘故。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述就是写了几段rust代码的一些感受，都是一些浅显的东西，对于常听说的“所有权”、“并发”等相关概念的内容，虽有接触了解，但毕竟还未深入，等之后学到了再说。总体来说，经过这个小尝试和一些“客观的软文”的介绍，还是对rust这门语言充满兴趣的，期待后续学习。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Gem or Not</title>
    <link rel="alternate" href="http://lafwind.github.io/two-ways-of-building-rails-app.html"/>
    <id>http://lafwind.github.io/two-ways-of-building-rails-app.html</id>
    <published>2015-06-05T22:14:00+08:00</published>
    <updated>2015-06-15T17:04:54+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;玩Ruby on Rails一段时间了，一直是所有代码自己手写（不借助其他gem，当然rails原生的还是要用的~），这段时间为了熟悉各种gem，把一些相应的功能都用gem来替代，也算完成了一个项目。&lt;/p&gt;

&lt;p&gt;而这两种方式也给我带来了不同的感受：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手写相应的逻辑代码能够让自己对该功能有更具体的认识，比如关于注册登入登出等功能，手写的就能对session、cookie等内容有深入了解，而如果直接利用&lt;a href="https://github.com/plataformatec/devise"&gt;Devise&lt;/a&gt;这个gem，则这些内容对于自己就相当于黑箱，虽然也能够完成功能。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用gem可以更快速的实现功能。比如本次项目从开始到基本完成所有功能大概就只花了大概3个小时（不包括页面设计）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手写代码更容易定制或扩展功能，而利用gem虽然读完相应的文档也能在该gem的支持下实现部分扩展功能，但仍然会有些限制。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述三点就是通过两种不同方式完成项目的一些感受，总结一下，如果需要快速完成项目原型或后期相应功能不需要太大改变，可以多利用gem，但是当之后需要有不断扩展时，可能自己实现会更好一些（当然如果允许，也可以深入hack相关的gem）。还有，学习阶段应多自己手动完成功能以取得更多的进步。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby对象模型（3）</title>
    <link rel="alternate" href="http://lafwind.github.io/the-object-model-of-ruby-3.html"/>
    <id>http://lafwind.github.io/the-object-model-of-ruby-3.html</id>
    <published>2015-04-13T18:10:00+08:00</published>
    <updated>2015-06-14T17:02:08+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;在&lt;a href="https:"&gt;上篇&lt;/a&gt;说完普通对象的对象模型，这次该讨论类对象的对象模型了。待续！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Ruby对象模型（2）</title>
    <link rel="alternate" href="http://lafwind.github.io/the-object-model-of-ruby-2.html"/>
    <id>http://lafwind.github.io/the-object-model-of-ruby-2.html</id>
    <published>2015-04-11T21:26:00+08:00</published>
    <updated>2015-06-16T21:14:22+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;&lt;a href="https:"&gt;前文&lt;/a&gt;介绍了对象、类、模块等的概念后，该正式进入主题了——对象模型。其实说白了，就是XX在哪呢~&lt;/p&gt;

&lt;p&gt;比如，一个对象（可能是类）调用了一个方法，这个方法到底在哪，为什么别的对象无法调用，搞清了对象模型，也就能搞定类似问题。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;P.S: 由于类也是对象，由Class类生成，为了便于行文，把这种对象称为类对象&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;先从对象说起吧（此处不包含类，因为类相对于普通对象还具有超类这个属性）。当对象调用一个方法时，到底发生了啥？很简单，在对象模型里找方法，然后调用之。而这个寻找的路径，也就构成了对象模型的一部分。&lt;/p&gt;

&lt;p&gt;利用上面使用的ancestors方法，我们知道对象调用的方法就存在于它的祖先链中，那么针对下面这种情况呢：&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"hello"&lt;/span&gt;

&lt;span class="c1"&gt;# A&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nc"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;say&lt;/span&gt;
  &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; String&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;say&lt;/span&gt;   &lt;span class="c1"&gt;# =&amp;gt; "hello"&lt;/span&gt;

&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"en"&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="c1"&gt;# =&amp;gt; String&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;say&lt;/span&gt;   &lt;span class="c1"&gt;# undefined method `say' for "en":String (NoMethodError)&lt;/span&gt;

&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="no"&gt;String&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;ancestors&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;明显，a和b都是String类生成的对象，但是在经过定义后，a对象拥有了say()方法，而b对象则无此方法，再看两者的祖先链，明显仍是一样的，那么此时say()方法放在哪呢？&lt;/p&gt;

&lt;p&gt;这就涉及到eigenclass，上面程序中，在A处为a对象定义了只属于a的方法（单件方法），而这些方法就存在a的eigenclass中，a是这个eigenclass的唯一实例（且eigenclass不能被继承）。再看代码：&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="c1"&gt;# 给每个对象定义eigenclass方法&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Object&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;eigenclass&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;
      &lt;span class="nb"&gt;self&lt;/span&gt;
    &lt;span class="k"&gt;end&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;M&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"M"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;

  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;world&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"world"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;N&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;M&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;new&lt;/span&gt;

&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hello&lt;/span&gt;                     &lt;span class="c1"&gt;# =&amp;gt; M&lt;/span&gt;
&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;world&lt;/span&gt;                     &lt;span class="c1"&gt;# =&amp;gt; world&lt;/span&gt;
&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;ancestors&lt;/span&gt;               &lt;span class="c1"&gt;# =&amp;gt; [N, M, Object, Kernel, BasicObject]&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;
    &lt;span class="nb"&gt;puts&lt;/span&gt; &lt;span class="s2"&gt;"eigenclass"&lt;/span&gt;
  &lt;span class="k"&gt;end&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;

&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;hello&lt;/span&gt;                     &lt;span class="c1"&gt;# =&amp;gt; eigenclass&lt;/span&gt;
&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;world&lt;/span&gt;                     &lt;span class="c1"&gt;# =&amp;gt; world&lt;/span&gt;
&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="no"&gt;N&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;ancestors&lt;/span&gt;               &lt;span class="c1"&gt;# =&amp;gt; [N, M, Object, Kernel, BasicObject]&lt;/span&gt;

&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;eigenclass&lt;/span&gt;              &lt;span class="c1"&gt;# =&amp;gt; #&amp;lt;Class:#&amp;lt;N:0x007fd209499f20&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;eigenclass&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;class&lt;/span&gt;        &lt;span class="c1"&gt;# =&amp;gt; Class&lt;/span&gt;
&lt;span class="nb"&gt;p&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;eigenclass&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;superclass&lt;/span&gt;   &lt;span class="c1"&gt;# =&amp;gt; N&lt;/span&gt;


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因此，现在可以总结普通对象部分的对象模型了：&lt;/p&gt;

&lt;p&gt;每个普通对象都有自己真正的类，这个类可能是普通类，也可能是eigenclass，如果是eigenclass，则eigenclass的父类是生成该对象的类（上述例子中是N）；如果没有eigenclass，那么就是普通类（上述例子中是N），以上面的例子看，有如下两情况：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;未加入单件方法：n -&amp;gt; N -&amp;gt; M -&amp;gt; Object -&amp;gt; Kernel -&amp;gt; BasicObject&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;加入单件方法后：n -&amp;gt; eigenclass -&amp;gt; N -&amp;gt; M -&amp;gt; Object -&amp;gt; Kernel -&amp;gt; BasicObject&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;方法查找也是根据属于上面何种情况来进行，n为对象本身，之后为n的祖先链。&lt;/p&gt;

&lt;p&gt;这就是普通对象的对象模型。在脑中存有这个模型图像，至于如何定义单件方法及一些相关详情，可参考《Ruby 元编程》相关笔记&lt;a href="https://github.com/lafwind/notes_of_metaprogramming_ruby/blob/master/chapter_1.markdown"&gt;1&lt;/a&gt;，&lt;a href="https://github.com/lafwind/notes_of_metaprogramming_ruby/blob/master/chapter_4.markdown"&gt;2&lt;/a&gt;，或上网查询。&lt;/p&gt;

&lt;p&gt;这篇文章完成了普通对象的对象模型，后续还有类对象的对象模型和其他内容。&lt;/p&gt;
</content>
  </entry>
</feed>
