<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lafwind's blog</title>
  <subtitle>A developer...</subtitle>
  <id>http://lafwind.github.io</id>
  <link href="http://lafwind.github.io"/>
  <link href="http://lafwind.github.io/feed.xml" rel="self"/>
  <updated>2015-11-26T23:43:00+08:00</updated>
  <author>
    <name>Lafwind</name>
  </author>
  <entry>
    <title>近期总结</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/summary-at-2015-11-26.html"/>
    <id>http://lafwind.github.io/blog/summary-at-2015-11-26.html</id>
    <published>2015-11-26T23:43:00+08:00</published>
    <updated>2015-11-26T23:44:03+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html"></content>
  </entry>
  <entry>
    <title>关于 Impage</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/impage.html"/>
    <id>http://lafwind.github.io/blog/impage.html</id>
    <published>2015-11-19T23:43:00+08:00</published>
    <updated>2015-11-19T23:57:58+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html"></content>
  </entry>
  <entry>
    <title>The Webpack Tutorial</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/the-webpack-tutorial.html"/>
    <id>http://lafwind.github.io/blog/the-webpack-tutorial.html</id>
    <published>2015-11-05T23:10:00+08:00</published>
    <updated>2015-11-05T23:11:03+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html"></content>
  </entry>
  <entry>
    <title>Number of trailing zeros of N!</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/number-of-trailing-zeros-of-n.html"/>
    <id>http://lafwind.github.io/blog/number-of-trailing-zeros-of-n.html</id>
    <published>2015-07-16T22:21:00+08:00</published>
    <updated>2015-07-16T22:27:07+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html"></content>
  </entry>
  <entry>
    <title>2015下半年计划</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/the-second-half-of-2015.html"/>
    <id>http://lafwind.github.io/blog/the-second-half-of-2015.html</id>
    <published>2015-07-03T20:44:00+08:00</published>
    <updated>2015-07-06T16:00:54+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;2015年又过去了一半，时间的转瞬即逝让人有点措手不及……&lt;/p&gt;

&lt;p&gt;由于开始写博客时，2015年已经过去了几个月，无法赶潮流的写一篇2014总结及2015展望，所以趁着半年之际，也来过过这把隐～刚过去的半年，对我而言，平常却不平凡，等收拾好心情再来总结；而对即将到来的日子，计划如下：&lt;/p&gt;

&lt;h3&gt;技术方面&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ruby/Ruby on Rails：毫无疑问地继续深入学习Ruby和Rails，扎实基础、提高水平。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端：HTML（haml）和CSS（Sass）继续学习及应用。Js系语言还有不足。虽然经常在Youtube上看JavaScript和JQuery的教程，然而道理我都懂，但是缺少实践啊！下半年认真巩固Js方面的基础；学习CoffeeScript，读完《深入浅出CoffeeScript》并完成书上例子；继续学习AngularJs，虽然之前有用过AngularJs完成一个小应用，但由于AngularJs2相对于AngularJs1存在较大变更，就暂缓了学习进度，下半年继续（同时关注&lt;a href="http://www.ionicframework.com/"&gt;Ionic框架&lt;/a&gt;）；关注&lt;a href="http://facebook.github.io/react/"&gt;React&lt;/a&gt;。总之，学习、实践！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lisp/Rust/Node。看&lt;a href="https://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;SICP&lt;/a&gt;，学习Lisp(scheme)，学习Functional Programming。四月份的时候看&lt;a href="https://www.youtube.com/playlist?list=PL26Nnis8vxRjnirJl1YvHkB8Wyn-WLeDF"&gt;SICP的配套视频课程&lt;/a&gt;，可惜由于一些事情中断了，下半年继续。对Rust、Node持续关注。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据库：深入学习一种关系数据库（如PostgreSql）；读《Redis设计与实现》，继续将Redis应用到项目中；如有时间，可尝试学习另一种非关系型数据库。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试：虽然自己也在一些小项目中尝试用Minitest来写测试，但还用得太少。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他：根据需要进行学习，并保持足够想象空间～&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;读书&lt;/h3&gt;

&lt;p&gt;除了上述列出的相关技术的书籍外，还希望自己在其他方面也有所涉略&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计：《写给大家看的设计书》、《认知与设计：理解UI设计准则》等&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;人文社科：《编码》、《失控》、人文历史方面的书籍等&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;运动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;跑步，答应某同学的话一定会做到的！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看着上面列出的这么一大串内容（其实还有更多 = =，毕竟自己是个兴趣广泛的人 = =，但现阶段还是希望能把精力集中在某些方面！），真心感觉时间不够用……加油吧！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rails 中的 cache（一）</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/cache-in-rails.html"/>
    <id>http://lafwind.github.io/blog/cache-in-rails.html</id>
    <published>2015-06-22T23:52:00+08:00</published>
    <updated>2015-06-25T00:54:18+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;其实，写这篇文章，自己有点心虚……首先，内容有点大；其次，我几乎没有在Rails中使用cache的经验= =，因为项目还没有这个需要T.T（Donald Knuth曾说过“过早的优化是万恶之源”，这是自我安慰吗～？），但是由于这几天都在看有关优化方面的内容，比如 &lt;a href="http://thenewstack.io/how-to-write-ruby-faster-at-the-source-code-level/"&gt;How To Write Ruby Faster at the Source Code Level&lt;/a&gt;，&lt;a href="https://github.com/JuanitoFatas/fast-ruby"&gt;fast-ruby&lt;/a&gt; 以及cache相关的内容，所以就想把相关内容记录下来，以备将来之需！&lt;/p&gt;

&lt;p&gt;p.s.：之所以在未经充分实践就把文章写下来的最主要原因是：平时自己就喜欢乱看东西，比如曾经看了haskell，go等，但由于没有实践，现在都差不多忘了，以至于白白浪费了之前的学习，为了避免重蹈覆辙，决定把学到的东西（不管开始用没）记录下来，当之后用到时也能通过这些文章更快地进入状态，这也是我之前说的想要写博客的原因之一；而这也从另一方面督促自己，还有很多东西没做呢！要把时间花在刀刃上！&lt;/p&gt;

&lt;p&gt;言归正传，就如上文所说，cache的内容有点多，有服务器端的、客户端的及一些页面相关的，在此次文章中，我主要想看看rails中的&lt;a href="http://guides.rubyonrails.org/caching_with_rails.html"&gt;Fragment Caching&lt;/a&gt;。这种缓存是把视图逻辑中的一部分打包到cache块中，之后的请求就会从缓存中取得这部分的内容。比如在一个图片网站中（像&lt;a href="https://impage.herokuapp.com/"&gt;Impage&lt;/a&gt; ; )），一般情况，图片的内容是不会变的，但是评论的内容则会慢慢增加，这种情况下，就可以将图片部分的相关视图缓存起来，而不用每次都像数据库发出请求，以此提高速度。代码方面如下：&lt;/p&gt;
&lt;pre class="highlight haml"&gt;&lt;code&gt;# example
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="nt"&gt;%p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;title&lt;/span&gt;
  &lt;span class="nt"&gt;%span&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;email&lt;/span&gt;
  &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;tag_list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;each&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;link_to&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;tag: &lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="ss"&gt;class: &lt;/span&gt;&lt;span class="s2"&gt;"btn"&lt;/span&gt;
  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_tag&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:large&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nt"&gt;%p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;description&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是一个使用fragment caching的例子，而cache[@post]会生成类似下列的key：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;views/posts/3-20150616162219&lt;/code&gt;，这个键包含模型名，post的id和最后更新时间updated_at，所以当post出现更新时（即updated_at更改），这个post才会生成一个新的缓存，而旧的缓存就不再管理，等到缓存满了后会利用LRU自动清理。&lt;/p&gt;

&lt;p&gt;除了上述的自动更新缓存外，也可以利用&lt;code&gt;expire_fragment&lt;/code&gt;方法来手动清除缓存。&lt;/p&gt;

&lt;p&gt;以上是fragment cache的一些基本内容。试想在这样一种情况下：缓存了一个大页面，此时有一个小小的section更新了，那么这个大页面的缓存也必须得更新，这样显然降低了效率。应对这种情况，rails提供了嵌套方式来重用缓存，如：&lt;/p&gt;
&lt;pre class="highlight haml"&gt;&lt;code&gt;# example 伪代码
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="vi"&gt;@posts&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="vi"&gt;@posts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;each&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当有一个post更新时，就仅更新该post的缓存，然后重新和其他post的缓存（沿用之前的）拼接，提高了效率，这种机制称为Russian Doll机制（套娃机制）。而在1:1或1：n（belongs_to）的情况下，比如：&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Item&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
    &lt;span class="n"&gt;belongs_to&lt;/span&gt; &lt;span class="ss"&gt;:list&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，在item更新时，并不会提示list的缓存也更新，解决的方法是利用touch属性：&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Item&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Activerecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
    &lt;span class="n"&gt;belongs_to&lt;/span&gt; &lt;span class="ss"&gt;:list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;touch: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当item更新，list也会跟着更新，有关套娃机制的内容，请参看Ruby-China上的&lt;a href="https://ruby-china.org/topics/21488"&gt;说说 Rails 的套娃缓存机制&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;上述就是这两天对于fragment cache的学习，之后会对其进行实践，如有新的理解，会接着更新。而后续也会对其他cache进行学习。&lt;/p&gt;
</content>
  </entry>
</feed>
