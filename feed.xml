<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lafwind's blog</title>
  <subtitle>A developer...</subtitle>
  <id>http://lafwind.github.io</id>
  <link href="http://lafwind.github.io"/>
  <link href="http://lafwind.github.io/feed.xml" rel="self"/>
  <updated>2015-11-19T23:43:00+08:00</updated>
  <author>
    <name>Lafwind</name>
  </author>
  <entry>
    <title>关于 Impage</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/impage.html"/>
    <id>http://lafwind.github.io/blog/impage.html</id>
    <published>2015-11-19T23:43:00+08:00</published>
    <updated>2015-11-19T23:57:58+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html"></content>
  </entry>
  <entry>
    <title>The Webpack Tutorial</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/the-webpack-tutorial.html"/>
    <id>http://lafwind.github.io/blog/the-webpack-tutorial.html</id>
    <published>2015-11-05T23:10:00+08:00</published>
    <updated>2015-11-05T23:11:03+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html"></content>
  </entry>
  <entry>
    <title>Number of trailing zeros of N!</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/number-of-trailing-zeros-of-n.html"/>
    <id>http://lafwind.github.io/blog/number-of-trailing-zeros-of-n.html</id>
    <published>2015-07-16T22:21:00+08:00</published>
    <updated>2015-07-16T22:27:07+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html"></content>
  </entry>
  <entry>
    <title>2015下半年计划</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/the-second-half-of-2015.html"/>
    <id>http://lafwind.github.io/blog/the-second-half-of-2015.html</id>
    <published>2015-07-03T20:44:00+08:00</published>
    <updated>2015-07-06T16:00:54+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;2015年又过去了一半，时间的转瞬即逝让人有点措手不及……&lt;/p&gt;

&lt;p&gt;由于开始写博客时，2015年已经过去了几个月，无法赶潮流的写一篇2014总结及2015展望，所以趁着半年之际，也来过过这把隐～刚过去的半年，对我而言，平常却不平凡，等收拾好心情再来总结；而对即将到来的日子，计划如下：&lt;/p&gt;

&lt;h3&gt;技术方面&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Ruby/Ruby on Rails：毫无疑问地继续深入学习Ruby和Rails，扎实基础、提高水平。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;前端：HTML（haml）和CSS（Sass）继续学习及应用。Js系语言还有不足。虽然经常在Youtube上看JavaScript和JQuery的教程，然而道理我都懂，但是缺少实践啊！下半年认真巩固Js方面的基础；学习CoffeeScript，读完《深入浅出CoffeeScript》并完成书上例子；继续学习AngularJs，虽然之前有用过AngularJs完成一个小应用，但由于AngularJs2相对于AngularJs1存在较大变更，就暂缓了学习进度，下半年继续（同时关注&lt;a href="http://www.ionicframework.com/"&gt;Ionic框架&lt;/a&gt;）；关注&lt;a href="http://facebook.github.io/react/"&gt;React&lt;/a&gt;。总之，学习、实践！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lisp/Rust/Node。看&lt;a href="https://mitpress.mit.edu/sicp/full-text/book/book.html"&gt;SICP&lt;/a&gt;，学习Lisp(scheme)，学习Functional Programming。四月份的时候看&lt;a href="https://www.youtube.com/playlist?list=PL26Nnis8vxRjnirJl1YvHkB8Wyn-WLeDF"&gt;SICP的配套视频课程&lt;/a&gt;，可惜由于一些事情中断了，下半年继续。对Rust、Node持续关注。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据库：深入学习一种关系数据库（如PostgreSql）；读《Redis设计与实现》，继续将Redis应用到项目中；如有时间，可尝试学习另一种非关系型数据库。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;测试：虽然自己也在一些小项目中尝试用Minitest来写测试，但还用得太少。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他：根据需要进行学习，并保持足够想象空间～&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;读书&lt;/h3&gt;

&lt;p&gt;除了上述列出的相关技术的书籍外，还希望自己在其他方面也有所涉略&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设计：《写给大家看的设计书》、《认知与设计：理解UI设计准则》等&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;人文社科：《编码》、《失控》、人文历史方面的书籍等&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;运动&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;跑步，答应某同学的话一定会做到的！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其他&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看着上面列出的这么一大串内容（其实还有更多 = =，毕竟自己是个兴趣广泛的人 = =，但现阶段还是希望能把精力集中在某些方面！），真心感觉时间不够用……加油吧！&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>Rails 中的 cache（一）</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/cache-in-rails.html"/>
    <id>http://lafwind.github.io/blog/cache-in-rails.html</id>
    <published>2015-06-22T23:52:00+08:00</published>
    <updated>2015-06-25T00:54:18+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;其实，写这篇文章，自己有点心虚……首先，内容有点大；其次，我几乎没有在Rails中使用cache的经验= =，因为项目还没有这个需要T.T（Donald Knuth曾说过“过早的优化是万恶之源”，这是自我安慰吗～？），但是由于这几天都在看有关优化方面的内容，比如 &lt;a href="http://thenewstack.io/how-to-write-ruby-faster-at-the-source-code-level/"&gt;How To Write Ruby Faster at the Source Code Level&lt;/a&gt;，&lt;a href="https://github.com/JuanitoFatas/fast-ruby"&gt;fast-ruby&lt;/a&gt; 以及cache相关的内容，所以就想把相关内容记录下来，以备将来之需！&lt;/p&gt;

&lt;p&gt;p.s.：之所以在未经充分实践就把文章写下来的最主要原因是：平时自己就喜欢乱看东西，比如曾经看了haskell，go等，但由于没有实践，现在都差不多忘了，以至于白白浪费了之前的学习，为了避免重蹈覆辙，决定把学到的东西（不管开始用没）记录下来，当之后用到时也能通过这些文章更快地进入状态，这也是我之前说的想要写博客的原因之一；而这也从另一方面督促自己，还有很多东西没做呢！要把时间花在刀刃上！&lt;/p&gt;

&lt;p&gt;言归正传，就如上文所说，cache的内容有点多，有服务器端的、客户端的及一些页面相关的，在此次文章中，我主要想看看rails中的&lt;a href="http://guides.rubyonrails.org/caching_with_rails.html"&gt;Fragment Caching&lt;/a&gt;。这种缓存是把视图逻辑中的一部分打包到cache块中，之后的请求就会从缓存中取得这部分的内容。比如在一个图片网站中（像&lt;a href="https://impage.herokuapp.com/"&gt;Impage&lt;/a&gt; ; )），一般情况，图片的内容是不会变的，但是评论的内容则会慢慢增加，这种情况下，就可以将图片部分的相关视图缓存起来，而不用每次都像数据库发出请求，以此提高速度。代码方面如下：&lt;/p&gt;
&lt;pre class="highlight haml"&gt;&lt;code&gt;# example
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="nt"&gt;%p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;title&lt;/span&gt;
  &lt;span class="nt"&gt;%span&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;user&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;email&lt;/span&gt;
  &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;tag_list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;each&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;link_to&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="si"&gt;#{&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;root_path&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;tag: &lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="ss"&gt;class: &lt;/span&gt;&lt;span class="s2"&gt;"btn"&lt;/span&gt;
  &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;image_tag&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:large&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="nt"&gt;%p&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="vi"&gt;@post&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;description&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是一个使用fragment caching的例子，而cache[@post]会生成类似下列的key：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;views/posts/3-20150616162219&lt;/code&gt;，这个键包含模型名，post的id和最后更新时间updated_at，所以当post出现更新时（即updated_at更改），这个post才会生成一个新的缓存，而旧的缓存就不再管理，等到缓存满了后会利用LRU自动清理。&lt;/p&gt;

&lt;p&gt;除了上述的自动更新缓存外，也可以利用&lt;code&gt;expire_fragment&lt;/code&gt;方法来手动清除缓存。&lt;/p&gt;

&lt;p&gt;以上是fragment cache的一些基本内容。试想在这样一种情况下：缓存了一个大页面，此时有一个小小的section更新了，那么这个大页面的缓存也必须得更新，这样显然降低了效率。应对这种情况，rails提供了嵌套方式来重用缓存，如：&lt;/p&gt;
&lt;pre class="highlight haml"&gt;&lt;code&gt;# example 伪代码
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="vi"&gt;@posts&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="vi"&gt;@posts&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nf"&gt;each&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="o"&gt;|&lt;/span&gt;
    &lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当有一个post更新时，就仅更新该post的缓存，然后重新和其他post的缓存（沿用之前的）拼接，提高了效率，这种机制称为Russian Doll机制（套娃机制）。而在1:1或1：n（belongs_to）的情况下，比如：&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Item&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;ActiveRecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
    &lt;span class="n"&gt;belongs_to&lt;/span&gt; &lt;span class="ss"&gt;:list&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时，在item更新时，并不会提示list的缓存也更新，解决的方法是利用touch属性：&lt;/p&gt;
&lt;pre class="highlight ruby"&gt;&lt;code&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Item&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="no"&gt;Activerecord&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="no"&gt;Base&lt;/span&gt;
    &lt;span class="n"&gt;belongs_to&lt;/span&gt; &lt;span class="ss"&gt;:list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ss"&gt;touch: &lt;/span&gt;&lt;span class="kp"&gt;true&lt;/span&gt;
&lt;span class="k"&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，当item更新，list也会跟着更新，有关套娃机制的内容，请参看Ruby-China上的&lt;a href="https://ruby-china.org/topics/21488"&gt;说说 Rails 的套娃缓存机制&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;上述就是这两天对于fragment cache的学习，之后会对其进行实践，如有新的理解，会接着更新。而后续也会对其他cache进行学习。&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>My tools</title>
    <link rel="alternate" href="http://lafwind.github.io/blog/my-tools.html"/>
    <id>http://lafwind.github.io/blog/my-tools.html</id>
    <published>2015-06-11T23:01:00+08:00</published>
    <updated>2015-06-15T17:15:09+08:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;工欲善其事，必先利其器。下面是一些自己在日常开发中用到的工具：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux
大概在2012年9月份的时候开始使用Linux当自己的主力操作系统，用的是ubuntu发行版。之后的折腾也都是基于ubuntu上的。先从ubuntu跑到kubuntu，再到现在的&lt;a href="http://www.elementary.io/"&gt;Elementary OS&lt;/a&gt;。总体来说感觉很好，尤其是开发，在命令行下能解决大部分问题。虽然没有啥游戏，但好在自己不是很好这一口~&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Gvim/Vim
用Gvim/Vim的历史可以追溯到自己的高中时期 = =，虽然那时自己不搞开发，但是对所有新鲜的软件都很感兴趣，vim就是其中之一，虽然它的历史比我还长，但是在遇到它时，它对我而言是全新的。之后偶尔用它来处理文本（hjkl的训练在那时完成），Firefox上也装了Vimperator，瞬间幻觉自己X格提高了不少……之后把系统从windows切换到linux后，vim就顺理成章的成为自己的主力编辑器。没事就折腾代码配色，操作配置，有关插件等，直到它变得越来越顺手。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Emacs
没错，你没看错，我没打错，我们都没错（&lt;del&gt;，错的是这个世界~&lt;/del&gt;），除了vim，我还使用emacs……之所以使用它是因为在上面学习了些lisp，虽然lisp还没学好（会继续的！），但却把emacs配置得差不多……其实在使用过程中最大的收获还是知道了和vim完全不同的emacs的快捷键，而这一套快捷键不止可以在emacs中使用，在其他地方也有用武之地，比如命令行里同样支持C-a、C-e、C-f、C-b等的操作，而在Intellij idea IDE中，同样可以选择使用emacs的快捷键。而这也着实能在日常操作中提高效率（命令行），虽然相对于vim编辑时的高效，emacs的快捷键可能还有些差距（个人认为），但对于键盘党来说，仍然值得拥有！&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;zsh &amp;amp; tmux
其实bash用得也蛮顺的，但是zsh着实帮我提高了不少效率。zsh的配置用的是&lt;a href="https://github.com/robbyrussell/oh-my-zsh"&gt;oh-my-zsh&lt;/a&gt;，当然自己也根据情况进行了些修改。不过就像部分用户所说，oh-my-zsh好像有点重，一开始启动有时会比较慢。tmux被我拿来给终端分屏，不用每次开那么多的Terminal。开发Rails时，server运行一屏，vim一屏，console和普通命令行界面共享一屏（分居左右），用快捷键切换，很好。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Firefox &amp;amp; Chrome
Firefox大概从它的1.x版本开始用。配合着Vimperator、adblock plus等插件，用起来爽爽的。直到去年，在调某个网页的效果时，发现其和chrome的渲染好像还是有点差别的（更喜欢chrome的渲染），遂把主力浏览器换成chrome。对chrome的认识从它发布的那天开始，这主要是由于我曾经有很长一段时间陷入到寻找浏览器的坑里，手里主要用着Firefox，但是什么Opera，基于IE内核的其他浏览器、Safari等都没事就被我翻起来用用，再用用，这其中的原因当然是偶尔对手头的Firefox有不满 = =。所以chrome一出来，我就试用了，但由于不顺手（主要就是没有Firefox中Vimperator这种对我来说杀手级的add-on），最后还是回到Firefox怀抱。&lt;/p&gt;

&lt;p&gt;顺便说说，我之所以如此喜欢Vimperator，除了它能给我在浏览器中带来接近vim的高效操作外，还有就是它能让Firefox变得十分简洁，只有tab栏和命令栏，网页的可视界面很大，而且用起来很酷~~&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上述就是自己在开发时用得主要工具，对我来说，它们能满足我的现有需求，而对于有些人来说可能还不够，这是正常的，每个人都有属于自己的独特需求嘛，自己用得舒服就好~下面是上述工具的相关配置，有需自取，欢迎交流：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.vimrc"&gt;.vimrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/tree/master/.emacs.d"&gt;.emacs.d&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.zshrc"&gt;.zshrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.tmux.conf"&gt;.tmux.conf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href="https://github.com/lafwind/dotfile/blob/master/.vimperatorrc"&gt;.vimperatorrc&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>
